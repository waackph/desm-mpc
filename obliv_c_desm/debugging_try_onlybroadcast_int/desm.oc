#include<obliv.oh>
#include<stdio.h>

#include"desm.h"


long dotprod(long *vec1, long *vec2, int n){

	//Initilize obliv variables
	long sum;
	//Initilize loop-helper
	int i;

	sum = 0;

	for(i = 0; i < n; i = i+1){
		sum = sum + vec1[i]*vec2[i];
	}

	return sum;
}

long computeCosine(long *query, long *doc, int n, long normQ, long normD){

	//Initilize obliv variables
	long dotDoc;
	long result;

	dotDoc = dotprod(query, doc, n);

	result = dotDoc / normQ * normD;

	return result;
}

long computeScore(long **Q, long *D, int n, int Qn, long *normQ, long normD){

	//Initilize obliv variables
	long newCosine;
	long cosine;
	long result;

	//Initilize loop-helper
	int i;

	cosine = 0.0;

	for(i = 0; i < Qn; i = i+1){
		newCosine = computeCosine(Q[i], D, n, normQ[i], normD);
		cosine = cosine + newCosine;
	}

	result = cosine/Qn;

	return result;
}

void load_data(protocolIO *io, long **T, int amount){
	int k, l;
	printf("\nload data\n");
	for (k=0; k<amount; k++){
		printf("\n%d\n", k);
		for (l=0; l<200; l++){
			T[k][l] = (long)(io->vecs[k][l] * 10000);
		}
	}
}

void toObliv(int amount, long **ov, long **o, int party){
	int i, j;
	printf("\ntoObliv Party: %d\n", party);
	for (i=0; i<amount; i++){
		printf("\n%d\n", i);
		for (j=0; j<200; j++){
			ov[i][j] = ocBroadcastLong(o[i][j], party);
		}
	}
}

void euclidToObliv(int amount, long *ov, long *o, int party){
	int i;
	printf("\neuclidToObliv\n");
	for(i=0; i<amount; i++){
		printf("\n%d\n", i);
		ov[i] = ocBroadcastLong(o[i], party);
	}
}

void desm(void* args){
	protocolIO *io = (protocolIO*) args;

	//Initilize & feed obliv variables

	//Amount of Documents and Queries (stays constant)
	//cant be obliv, because they are needed for several loops

	printf("\ninitilize constants\n");

	const int Dm;
	const int Qm;
	const int n;
	//Helper variable for loops 
	int i;

	Dm = ocBroadcastInt(io->m, 1);
	Qm = ocBroadcastInt(io->m, 2);
	n = io->n;

	//allocate the 2-dim. Vector-Arrays (Documents, Queries), need to be obliv!

	printf("\nallocate arrays\n");

	//After many different apporaches I am (for now) using a Double-pointer
	long **Dt = malloc(5*sizeof(long*));
	for(i=0; i<5; i++){
		Dt[i] = malloc(200*sizeof(long));
	}
	long **Qt = malloc(1*sizeof(long*));
	for(i=0; i<1; i++){
		Qt[i] = malloc(200*sizeof(long));
	}

	long **D = malloc(5*sizeof(long*));
	for(i=0; i<5; i++){
		D[i] = malloc(200*sizeof(long));
	}
	long **Q = malloc(1*sizeof(long*));
	for(i=0; i<1; i++){
		Q[i] = malloc(200*sizeof(long));
	}

	//Allocate memory to compute/save the euclidean distances locally
	long *normDt = malloc(5*sizeof(long));
	long *normQt = malloc(1*sizeof(long));
	long *normD = malloc(5*sizeof(long));
	long *normQ = malloc(1*sizeof(long));

	//Print an item from the query or document matrix (depending on party) (for debugging)
	printf("\n\nTest, element of vectors: %f\n\n", io->vecs[0][7]);

	//convert the 2-Dim. Arrays of the structs to obliv Arrays

	printf("\nload data\n");

	//assign the data locally (for testing purposes)	
	if(ocCurrentParty()==1){
		load_data(io, Dt, Dm);
		printf("\n\n%d\n\n", Dt[0][7]);
	}
	if(ocCurrentParty()==2){
		load_data(io, Qt, Qm);
		printf("\n\n%d\n\n", Qt[0][7]);
	}

	printf("\ndistribute data\n");

	//Use the locally assigned data to assign it to obliv array (using pointers)
	//if(ocCurrentParty()==1){
	//	toObliv(Dm, D, Dt, 1);
	//}
	//if(ocCurrentParty()==2){
	//	toObliv(Qm, Q, Qt, 2);
	//}

	int j;
	printf("\ntoObliv Party: %d\n", ocCurrentParty());
	if(ocCurrentParty()==1){
		for (i=0; i<Dm; i++){
			printf("\n%d\n", i);
			for (j=0; j<200; j++){
				D[i][j] = ocBroadcastLong(Dt[i][j], ocCurrentParty());
			}
		}
	}

	if(ocCurrentParty()==2){
		for (i=0; i<Qm; i++){
			printf("\n%d\n", i);
			for (j=0; j<200; j++){
				Q[i][j] = ocBroadcastLong(Qt[i][j], ocCurrentParty());
			}
		}
	}

	printf("\ncompute euclidean norm\n");

	//Compute euclidean distances locally
	for(i=0; i<Qm; i++){
		normQt[i] = euclid(Qt[i], n);
	}
	for(i=0; i<Dm; i++){
		normDt[i] = euclid(Dt[i], n);
	}

	printf("\ndistribute norm\n");

	//Distribute local data obliviously
	if(ocCurrentParty()==1){
		euclidToObliv(Dm, normD, normDt, 1);
	}
	if(ocCurrentParty()==2){
		euclidToObliv(Qm, normQ, normQt, 2);
	}

	//Initilize, assign and print the first item of the Document-Matrix (for debugging)
	long testval = 1;

	printf("\nTestvalue: %d\n", testval);

	//revealOblivFloat(&testval, D[0][0], 1);

	if(ocCurrentParty()==1){
		printf("\n\nTestvalue: %d\n\n", D[0][0]); //testval);
	}

	//Allocate obliv score-values
	long *score = malloc(sizeof(long) * Dm);

	printf("\nCompute Scores\n");

	//Compute (per document-vector) the desm-score (in oblivious fashion)
	for(i=0; i<Dm; i++){
		score[i] = computeScore(Q, D[i], 200, Qm, normQ, normD[i]);
	}

	printf("\nReveal Scores\n");

	//Reveal the scores to the 2. Party which provided the query
	for (i = 0; i<Dm; i++){
		//revealOblivFloat(&io->scores[i], score[i], 2);
		io->scores[i] = (float)score[i];
	}
}
